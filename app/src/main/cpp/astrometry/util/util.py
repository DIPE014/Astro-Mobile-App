# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _util
else:
    import _util

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def log_init(level):
    return _util.log_init(level)

def log_get_level():
    return _util.log_get_level()

def log_set_level(lvl):
    return _util.log_set_level(lvl)
class coadd_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    img = property(_util.coadd_t_img_get, _util.coadd_t_img_set)
    weight = property(_util.coadd_t_weight_get, _util.coadd_t_weight_set)
    W = property(_util.coadd_t_W_get, _util.coadd_t_W_set)
    H = property(_util.coadd_t_H_get, _util.coadd_t_H_set)
    wcs = property(_util.coadd_t_wcs_get, _util.coadd_t_wcs_set)
    resample_func = property(_util.coadd_t_resample_func_get, _util.coadd_t_resample_func_set)
    resample_token = property(_util.coadd_t_resample_token_get, _util.coadd_t_resample_token_set)

    def __init__(self):
        _util.coadd_t_swiginit(self, _util.new_coadd_t())
    __swig_destroy__ = _util.delete_coadd_t

# Register coadd_t in _util:
_util.coadd_t_swigregister(coadd_t)


def coadd_new(W, H):
    return _util.coadd_new(W, H)

def coadd_new_from_wcs(wcs):
    return _util.coadd_new_from_wcs(wcs)

def coadd_set_lanczos(co, Lorder):
    return _util.coadd_set_lanczos(co, Lorder)

def coadd_add_image(c, img, weightimg, weight, wcs):
    return _util.coadd_add_image(c, img, weightimg, weight, wcs)

def coadd_divide_by_weight(c, badpix):
    return _util.coadd_divide_by_weight(c, badpix)

def coadd_get_snapshot(c, outimg, badpix):
    return _util.coadd_get_snapshot(c, outimg, badpix)

def coadd_free(c):
    return _util.coadd_free(c)

def coadd_debug(co):
    return _util.coadd_debug(co)

def coadd_create_weight_image_from_range(img, W, H, lowval, highval):
    return _util.coadd_create_weight_image_from_range(img, W, H, lowval, highval)

def coadd_weight_image_mask_value(img, W, H, weight, badval):
    return _util.coadd_weight_image_mask_value(img, W, H, weight, badval)
class lanczos_args_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    order = property(_util.lanczos_args_t_order_get, _util.lanczos_args_t_order_set)
    weighted = property(_util.lanczos_args_t_weighted_get, _util.lanczos_args_t_weighted_set)

    def __init__(self):
        _util.lanczos_args_t_swiginit(self, _util.new_lanczos_args_t())
    __swig_destroy__ = _util.delete_lanczos_args_t

# Register lanczos_args_t in _util:
_util.lanczos_args_t_swigregister(lanczos_args_t)


def lanczos(x, order):
    return _util.lanczos(x, order)

def nearest_resample_f(px, py, img, weightimg, W, H, out_wt, token):
    return _util.nearest_resample_f(px, py, img, weightimg, W, H, out_wt, token)

def lanczos_resample_f(px, py, img, weightimg, W, H, out_wt, token):
    return _util.lanczos_resample_f(px, py, img, weightimg, W, H, out_wt, token)

def lanczos_resample_unw_sep_f(px, py, img, W, H, token):
    return _util.lanczos_resample_unw_sep_f(px, py, img, W, H, token)

def nearest_resample_d(px, py, img, weightimg, W, H, out_wt, token):
    return _util.nearest_resample_d(px, py, img, weightimg, W, H, out_wt, token)

def lanczos_resample_d(px, py, img, weightimg, W, H, out_wt, token):
    return _util.lanczos_resample_d(px, py, img, weightimg, W, H, out_wt, token)
TRUE = _util.TRUE
FALSE = _util.FALSE

def fit_sip_coefficients(starxyz, fieldxy, weights, M, tanin1, sip_order, inv_order, sipout):
    return _util.fit_sip_coefficients(starxyz, fieldxy, weights, M, tanin1, sip_order, inv_order, sipout)

def wcs_shift(wcs, xs, ys):
    return _util.wcs_shift(wcs, xs, ys)

def fit_sip_wcs(starxyz, fieldxy, weights, M, tanin, sip_order, inv_order, doshift, sipout):
    return _util.fit_sip_wcs(starxyz, fieldxy, weights, M, tanin, sip_order, inv_order, doshift, sipout)

def fit_sip_wcs_2(starxyz, fieldxy, weights, M, sip_order, inv_order, W, H, crpix_center, crpix, doshift, sipout):
    return _util.fit_sip_wcs_2(starxyz, fieldxy, weights, M, sip_order, inv_order, W, H, crpix_center, crpix, doshift, sipout)

def fit_tan_wcs_move_tangent_point(starxyz, fieldxy, N, crpix, tanin, tanout):
    return _util.fit_tan_wcs_move_tangent_point(starxyz, fieldxy, N, crpix, tanin, tanout)

def fit_tan_wcs_move_tangent_point_weighted(starxyz, fieldxy, weights, N, crpix, tanin, tanout):
    return _util.fit_tan_wcs_move_tangent_point_weighted(starxyz, fieldxy, weights, N, crpix, tanin, tanout)

def fit_tan_wcs(starxyz, fieldxy, nobjs, wcstan, p_scale):
    return _util.fit_tan_wcs(starxyz, fieldxy, nobjs, wcstan, p_scale)

def fit_tan_wcs_weighted(starxyz, fieldxy, weights, N, tan, p_scale):
    return _util.fit_tan_wcs_weighted(starxyz, fieldxy, weights, N, tan, p_scale)

def print_array(arr):
    return _util.print_array(arr)

def an_hist2d(py_arrx, py_arry, py_hist, xlo, xhi, ylo, yhi):
    return _util.an_hist2d(py_arrx, py_arry, py_hist, xlo, xhi, ylo, yhi)

def flat_percentile_f(np_arr, pct):
    return _util.flat_percentile_f(np_arr, pct)

def flat_median_f(np_arr):
    return _util.flat_median_f(np_arr)

def median_smooth(py_image, py_mask, halfbox, py_smooth):
    return _util.median_smooth(py_image, py_mask, halfbox, py_smooth)
L = _util.L

def lanczos5_interpolate(np_ixi, np_iyi, np_dx, np_dy, loutputs, linputs):
    return _util.lanczos5_interpolate(np_ixi, np_iyi, np_dx, np_dy, loutputs, linputs)

def lanczos5_interpolate_grid(x0, xstep, y0, ystep, output_img, input_img):
    return _util.lanczos5_interpolate_grid(x0, xstep, y0, ystep, output_img, input_img)

def lanczos3_interpolate(np_ixi, np_iyi, np_dx, np_dy, loutputs, linputs):
    return _util.lanczos3_interpolate(np_ixi, np_iyi, np_dx, np_dy, loutputs, linputs)

def lanczos3_interpolate_grid(x0, xstep, y0, ystep, output_img, input_img):
    return _util.lanczos3_interpolate_grid(x0, xstep, y0, ystep, output_img, input_img)

def lanczos5_filter(py_dx, py_f):
    return _util.lanczos5_filter(py_dx, py_f)

def lanczos3_filter(py_dx, py_f):
    return _util.lanczos3_filter(py_dx, py_f)

def lanczos3_filter_table(py_dx, py_f, rangecheck):
    return _util.lanczos3_filter_table(py_dx, py_f, rangecheck)

def lanczos_shift_image_c(py_img, py_weight, py_outimg, py_outweight, order, dx, dy):
    return _util.lanczos_shift_image_c(py_img, py_weight, py_outimg, py_outweight, order, dx, dy)


def lanczos_shift_image(img, dx, dy, order=3, weight=None,
                        outimg=None, outweight=None):
    img = img.astype(float)
    if weight is not None:
        weight = weight.astype(float)
        assert(img.shape == weight.shape)
    if outimg is None:
        outimg = np.zeros_like(img)
    if outweight is not None:
        assert(outweight.shape == img.shape)

# print 'outweight:', outweight

    lanczos_shift_image_c(img, weight, outimg, outweight, order, dx, dy)
    if outweight is None:
        return outimg
    return outimg,outweight

DEFAULT_INDEX_JITTER = _util.DEFAULT_INDEX_JITTER
class index_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    codekd = property(_util.index_t_codekd_get, _util.index_t_codekd_set)
    quads = property(_util.index_t_quads_get, _util.index_t_quads_set)
    starkd = property(_util.index_t_starkd_get, _util.index_t_starkd_set)
    fits = property(_util.index_t_fits_get, _util.index_t_fits_set)
    indexfn = property(_util.index_t_indexfn_get, _util.index_t_indexfn_set)
    indexname = property(_util.index_t_indexname_get, _util.index_t_indexname_set)
    indexid = property(_util.index_t_indexid_get, _util.index_t_indexid_set)
    healpix = property(_util.index_t_healpix_get, _util.index_t_healpix_set)
    hpnside = property(_util.index_t_hpnside_get, _util.index_t_hpnside_set)
    index_jitter = property(_util.index_t_index_jitter_get, _util.index_t_index_jitter_set)
    cutnside = property(_util.index_t_cutnside_get, _util.index_t_cutnside_set)
    cutnsweep = property(_util.index_t_cutnsweep_get, _util.index_t_cutnsweep_set)
    cutdedup = property(_util.index_t_cutdedup_get, _util.index_t_cutdedup_set)
    cutband = property(_util.index_t_cutband_get, _util.index_t_cutband_set)
    cutmargin = property(_util.index_t_cutmargin_get, _util.index_t_cutmargin_set)
    circle = property(_util.index_t_circle_get, _util.index_t_circle_set)
    cx_less_than_dx = property(_util.index_t_cx_less_than_dx_get, _util.index_t_cx_less_than_dx_set)
    meanx_less_than_half = property(_util.index_t_meanx_less_than_half_get, _util.index_t_meanx_less_than_half_set)
    index_scale_upper = property(_util.index_t_index_scale_upper_get, _util.index_t_index_scale_upper_set)
    index_scale_lower = property(_util.index_t_index_scale_lower_get, _util.index_t_index_scale_lower_set)
    dimquads = property(_util.index_t_dimquads_get, _util.index_t_dimquads_set)
    nstars = property(_util.index_t_nstars_get, _util.index_t_nstars_set)
    nquads = property(_util.index_t_nquads_get, _util.index_t_nquads_set)

    def __init__(self):
        _util.index_t_swiginit(self, _util.new_index_t())
    __swig_destroy__ = _util.delete_index_t

# Register index_t in _util:
_util.index_t_swigregister(index_t)


def index_dimquads(indx):
    return _util.index_dimquads(indx)

def index_overlaps_scale_range(indx, quadlo, quadhi):
    return _util.index_overlaps_scale_range(indx, quadlo, quadhi)

def index_is_within_range(indx, ra, dec, radius_deg):
    return _util.index_is_within_range(indx, ra, dec, radius_deg)

def index_get_meta(filename, indx):
    return _util.index_get_meta(filename, indx)

def index_is_file_index(filename):
    return _util.index_is_file_index(filename)

def index_get_quad_filename(indexname):
    return _util.index_get_quad_filename(indexname)

def index_get_qidx_filename(indexname):
    return _util.index_get_qidx_filename(indexname)
INDEX_ONLY_LOAD_METADATA = _util.INDEX_ONLY_LOAD_METADATA

def index_get_quad_dim(index):
    return _util.index_get_quad_dim(index)

def index_get_code_dim(index):
    return _util.index_get_code_dim(index)

def index_nquads(index):
    return _util.index_nquads(index)

def index_nstars(index):
    return _util.index_nstars(index)

def index_build_from(codekd, quads, starkd):
    return _util.index_build_from(codekd, quads, starkd)

def index_load(indexname, flags, dest):
    return _util.index_load(indexname, flags, dest)

def index_unload(index):
    return _util.index_unload(index)

def index_reload(index):
    return _util.index_reload(index)

def index_close_fds(index):
    return _util.index_close_fds(index)

def index_close(index):
    return _util.index_close(index)

def index_free(index):
    return _util.index_free(index)

def index_get_missing_cut_params(indexid, hpnside, nsweep, dedup, margin, band):
    return _util.index_get_missing_cut_params(indexid, hpnside, nsweep, dedup, margin, band)
class quadfile_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numquads = property(_util.quadfile_t_numquads_get, _util.quadfile_t_numquads_set)
    numstars = property(_util.quadfile_t_numstars_get, _util.quadfile_t_numstars_set)
    dimquads = property(_util.quadfile_t_dimquads_get, _util.quadfile_t_dimquads_set)
    index_scale_upper = property(_util.quadfile_t_index_scale_upper_get, _util.quadfile_t_index_scale_upper_set)
    index_scale_lower = property(_util.quadfile_t_index_scale_lower_get, _util.quadfile_t_index_scale_lower_set)
    indexid = property(_util.quadfile_t_indexid_get, _util.quadfile_t_indexid_set)
    healpix = property(_util.quadfile_t_healpix_get, _util.quadfile_t_healpix_set)
    hpnside = property(_util.quadfile_t_hpnside_get, _util.quadfile_t_hpnside_set)
    fb = property(_util.quadfile_t_fb_get, _util.quadfile_t_fb_set)
    quadarray = property(_util.quadfile_t_quadarray_get, _util.quadfile_t_quadarray_set)

    def __init__(self):
        _util.quadfile_t_swiginit(self, _util.new_quadfile_t())
    __swig_destroy__ = _util.delete_quadfile_t

# Register quadfile_t in _util:
_util.quadfile_t_swigregister(quadfile_t)


def quadfile_open(fname):
    return _util.quadfile_open(fname)

def quadfile_open_fits(fits):
    return _util.quadfile_open_fits(fits)

def quadfile_get_filename(qf):
    return _util.quadfile_get_filename(qf)

def quadfile_open_for_writing(quadfname):
    return _util.quadfile_open_for_writing(quadfname)

def quadfile_open_in_memory():
    return _util.quadfile_open_in_memory()

def quadfile_switch_to_reading(qf):
    return _util.quadfile_switch_to_reading(qf)

def quadfile_close(qf):
    return _util.quadfile_close(qf)

def quadfile_check(qf):
    return _util.quadfile_check(qf)

def quadfile_get_stars(qf, quadid):
    return _util.quadfile_get_stars(qf, quadid)

def quadfile_write_quad(qf):
    return _util.quadfile_write_quad(qf)

def quadfile_dimquads(qf):
    return _util.quadfile_dimquads(qf)

def quadfile_nquads(qf):
    return _util.quadfile_nquads(qf)

def quadfile_fix_header(qf):
    return _util.quadfile_fix_header(qf)

def quadfile_write_header(qf):
    return _util.quadfile_write_header(qf)

def quadfile_get_index_scale_upper_arcsec(qf):
    return _util.quadfile_get_index_scale_upper_arcsec(qf)

def quadfile_get_index_scale_lower_arcsec(qf):
    return _util.quadfile_get_index_scale_lower_arcsec(qf)

def quadfile_get_header(qf):
    return _util.quadfile_get_header(qf)

def quadfile_write_header_to(qf, fid):
    return _util.quadfile_write_header_to(qf, fid)

def quadfile_write_all_quads_to(qf, fid):
    return _util.quadfile_write_all_quads_to(qf, fid)
AN_FILETYPE_CODETREE = _util.AN_FILETYPE_CODETREE
CODETREE_NAME = _util.CODETREE_NAME
class codetree_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tree = property(_util.codetree_t_tree_get, _util.codetree_t_tree_set)
    header = property(_util.codetree_t_header_get, _util.codetree_t_header_set)
    inverse_perm = property(_util.codetree_t_inverse_perm_get, _util.codetree_t_inverse_perm_set)

    def __init__(self):
        _util.codetree_t_swiginit(self, _util.new_codetree_t())
    __swig_destroy__ = _util.delete_codetree_t

# Register codetree_t in _util:
_util.codetree_t_swigregister(codetree_t)


def codetree_open(fn):
    return _util.codetree_open(fn)

def codetree_open_fits(fits):
    return _util.codetree_open_fits(fits)

def codetree_get(s, codeid, code):
    return _util.codetree_get(s, codeid, code)

def codetree_N(s):
    return _util.codetree_N(s)

def codetree_nodes(s):
    return _util.codetree_nodes(s)

def codetree_D(s):
    return _util.codetree_D(s)

def codetree_get_permuted(s, index):
    return _util.codetree_get_permuted(s, index)

def codetree_header(s):
    return _util.codetree_header(s)

def codetree_close(s):
    return _util.codetree_close(s)

def codetree_new():
    return _util.codetree_new()

def codetree_append_to(s, fid):
    return _util.codetree_append_to(s, fid)

def codetree_write_to_file(s, fn):
    return _util.codetree_write_to_file(s, fn)

def codetree_write_to_file_flipped(s, fn):
    return _util.codetree_write_to_file_flipped(s, fn)
AN_FILETYPE_STARTREE = _util.AN_FILETYPE_STARTREE
AN_FILETYPE_TAGALONG = _util.AN_FILETYPE_TAGALONG
STARTREE_NAME = _util.STARTREE_NAME
class startree_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tree = property(_util.startree_t_tree_get, _util.startree_t_tree_set)
    header = property(_util.startree_t_header_get, _util.startree_t_header_set)
    inverse_perm = property(_util.startree_t_inverse_perm_get, _util.startree_t_inverse_perm_set)
    sweep = property(_util.startree_t_sweep_get, _util.startree_t_sweep_set)
    writing = property(_util.startree_t_writing_get, _util.startree_t_writing_set)
    tagalong = property(_util.startree_t_tagalong_get, _util.startree_t_tagalong_set)

    def __init__(self):
        _util.startree_t_swiginit(self, _util.new_startree_t())
    __swig_destroy__ = _util.delete_startree_t

# Register startree_t in _util:
_util.startree_t_swigregister(startree_t)


def startree_open(fn):
    return _util.startree_open(fn)

def startree_open_fits(fits):
    return _util.startree_open_fits(fits)

def startree_search_for(s, xyzcenter, radius2, xyzresults, radecresults, starinds, nresults):
    return _util.startree_search_for(s, xyzcenter, radius2, xyzresults, radecresults, starinds, nresults)

def startree_search_for_radec(s, ra, dec, radius, xyzresults, radecresults, starinds, nresults):
    return _util.startree_search_for_radec(s, ra, dec, radius, xyzresults, radecresults, starinds, nresults)

def startree_search(s, xyzcenter, radius2, xyzresults, radecresults, nresults):
    return _util.startree_search(s, xyzcenter, radius2, xyzresults, radecresults, nresults)

def startree_get_data_column(s, colname, indices, N):
    return _util.startree_get_data_column(s, colname, indices, N)

def startree_get_data_column_int64(s, colname, indices, N):
    return _util.startree_get_data_column_int64(s, colname, indices, N)

def startree_get_data_column_array(s, colname, indices, N, arraysize):
    return _util.startree_get_data_column_array(s, colname, indices, N, arraysize)

def startree_free_data_column(s, d):
    return _util.startree_free_data_column(s, d)

def startree_has_tagalong(s):
    return _util.startree_has_tagalong(s)

def startree_get_tagalong(s):
    return _util.startree_get_tagalong(s)

def startree_get_tagalong_column_names(s, lst):
    return _util.startree_get_tagalong_column_names(s, lst)

def startree_get_tagalong_N_columns(s):
    return _util.startree_get_tagalong_N_columns(s)

def startree_get_tagalong_column_name(s, i):
    return _util.startree_get_tagalong_column_name(s, i)

def startree_get_tagalong_column_fits_type(s, i):
    return _util.startree_get_tagalong_column_fits_type(s, i)

def startree_get_tagalong_column_array_size(s, i):
    return _util.startree_get_tagalong_column_array_size(s, i)

def startree_get_cut_nside(s):
    return _util.startree_get_cut_nside(s)

def startree_get_cut_nsweeps(s):
    return _util.startree_get_cut_nsweeps(s)

def startree_get_cut_dedup(s):
    return _util.startree_get_cut_dedup(s)

def startree_get_cut_band(s):
    return _util.startree_get_cut_band(s)

def startree_get_cut_margin(s):
    return _util.startree_get_cut_margin(s)

def startree_get_jitter(s):
    return _util.startree_get_jitter(s)

def startree_set_jitter(s, jitter_arcsec):
    return _util.startree_set_jitter(s, jitter_arcsec)

def startree_get_sweep(s, ind):
    return _util.startree_get_sweep(s, ind)

def startree_N(s):
    return _util.startree_N(s)

def startree_nodes(s):
    return _util.startree_nodes(s)

def startree_D(s):
    return _util.startree_D(s)

def startree_header(s):
    return _util.startree_header(s)

def startree_get(s, starid):
    return _util.startree_get(s, starid)

def startree_get_radec(s, starid):
    return _util.startree_get_radec(s, starid)

def startree_close(s):
    return _util.startree_close(s)

def startree_compute_inverse_perm(s):
    return _util.startree_compute_inverse_perm(s)

def startree_check_inverse_perm(s):
    return _util.startree_check_inverse_perm(s)

def startree_new():
    return _util.startree_new()

def startree_write_to_file(s, fn):
    return _util.startree_write_to_file(s, fn)

def startree_write_to_file_flipped(s, fn):
    return _util.startree_write_to_file_flipped(s, fn)

def startree_append_to(s, fid):
    return _util.startree_append_to(s, fid)

def code_alloc(DC):
    return _util.code_alloc(DC)

def code_free(code):
    return _util.code_free(code)

def code_get(code, i):
    return _util.code_get(code, i)

def codekd_addr(ind):
    return _util.codekd_addr(ind)

def starkd_addr(ind):
    return _util.starkd_addr(ind)

def quadfile_addr(ind):
    return _util.quadfile_addr(ind)
HP_MAX_INT_NSIDE = _util.HP_MAX_INT_NSIDE

def healpix_xy_to_ring(hp, Nside):
    return _util.healpix_xy_to_ring(hp, Nside)

def healpix_ring_to_xy(ring_index, Nside):
    return _util.healpix_ring_to_xy(ring_index, Nside)

def healpix_xy_to_nested(hp, Nside):
    return _util.healpix_xy_to_nested(hp, Nside)

def healpix_nested_to_xy(nested_index, Nside):
    return _util.healpix_nested_to_xy(nested_index, Nside)

def healpix_decompose_ring(ring_index, Nside, p_ring_number, p_longitude_index):
    return _util.healpix_decompose_ring(ring_index, Nside, p_ring_number, p_longitude_index)

def healpix_compose_ring(ring, longind, Nside):
    return _util.healpix_compose_ring(ring, longind, Nside)

def healpix_decompose_xy(finehp, bighp, x, y, Nside):
    return _util.healpix_decompose_xy(finehp, bighp, x, y, Nside)

def healpix_decompose_xyl(finehp, bighp, x, y, Nside):
    return _util.healpix_decompose_xyl(finehp, bighp, x, y, Nside)

def healpix_compose_xy(bighp, x, y, Nside):
    return _util.healpix_compose_xy(bighp, x, y, Nside)

def healpix_compose_xyl(bighp, x, y, Nside):
    return _util.healpix_compose_xyl(bighp, x, y, Nside)

def healpix_convert_xy_nside(x, y, nside, outnside, outx, outy):
    return _util.healpix_convert_xy_nside(x, y, nside, outnside, outx, outy)

def healpix_convert_nside(hp, nside, outnside, outhp):
    return _util.healpix_convert_nside(hp, nside, outnside, outhp)

def healpix_convert_nsidel(hp, nside, outnside, outhp):
    return _util.healpix_convert_nsidel(hp, nside, outnside, outhp)

def radectohealpix(ra, dec, Nside):
    return _util.radectohealpix(ra, dec, Nside)

def radectohealpixf(ra, dec, Nside):
    return _util.radectohealpixf(ra, dec, Nside)

def radectohealpixl(ra, dec, Nside):
    return _util.radectohealpixl(ra, dec, Nside)

def radectohealpixlf(ra, dec, Nside):
    return _util.radectohealpixlf(ra, dec, Nside)

def radecdegtohealpix(ra, dec, Nside):
    return _util.radecdegtohealpix(ra, dec, Nside)

def radecdegtohealpixf(ra, dec, Nside):
    return _util.radecdegtohealpixf(ra, dec, Nside)

def radecdegtohealpixl(ra, dec, Nside):
    return _util.radecdegtohealpixl(ra, dec, Nside)

def radecdegtohealpixlf(ra, dec, Nside):
    return _util.radecdegtohealpixlf(ra, dec, Nside)

def xyztohealpix(x, y, z, Nside):
    return _util.xyztohealpix(x, y, z, Nside)

def xyztohealpixl(x, y, z, Nside):
    return _util.xyztohealpixl(x, y, z, Nside)

def xyztohealpixf(x, y, z, Nside):
    return _util.xyztohealpixf(x, y, z, Nside)

def xyztohealpixlf(x, y, z, Nside):
    return _util.xyztohealpixlf(x, y, z, Nside)

def xyzarrtohealpix(xyz, Nside):
    return _util.xyzarrtohealpix(xyz, Nside)

def xyzarrtohealpixl(xyz, Nside):
    return _util.xyzarrtohealpixl(xyz, Nside)

def xyzarrtohealpixf(xyz, Nside):
    return _util.xyzarrtohealpixf(xyz, Nside)

def healpix_to_xyz(hp, Nside, dx, dy):
    return _util.healpix_to_xyz(hp, Nside, dx, dy)

def healpix_to_xyzarr(hp, Nside, dx, dy, xyz):
    return _util.healpix_to_xyzarr(hp, Nside, dx, dy, xyz)

def healpixl_to_xyzarr(hp, Nside, dx, dy, xyz):
    return _util.healpixl_to_xyzarr(hp, Nside, dx, dy, xyz)

def healpix_to_radec(hp, Nside, dx, dy):
    return _util.healpix_to_radec(hp, Nside, dx, dy)

def healpix_to_radecdeg(hp, Nside, dx, dy):
    return _util.healpix_to_radecdeg(hp, Nside, dx, dy)

def healpixl_to_radecdeg(hp, Nside, dx, dy):
    return _util.healpixl_to_radecdeg(hp, Nside, dx, dy)

def healpix_to_radecarr(hp, Nside, dx, dy, radec):
    return _util.healpix_to_radecarr(hp, Nside, dx, dy, radec)

def healpix_to_radecdegarr(hp, Nside, dx, dy, radec):
    return _util.healpix_to_radecdegarr(hp, Nside, dx, dy, radec)

def healpix_side_length_arcmin(Nside):
    return _util.healpix_side_length_arcmin(Nside)

def healpix_nside_for_side_length_arcmin(arcmin):
    return _util.healpix_nside_for_side_length_arcmin(arcmin)

def healpix_get_neighbours(hp, Nside):
    return _util.healpix_get_neighbours(hp, Nside)

def healpix_get_neighboursl(pix, neighbour, Nside):
    return _util.healpix_get_neighboursl(pix, neighbour, Nside)

def healpix_get_neighbours_within_range(xyz, range, healpixes, Nside):
    return _util.healpix_get_neighbours_within_range(xyz, range, healpixes, Nside)

def healpix_get_neighbours_within_range_radec(ra, dec, radius, healpixes, Nside):
    return _util.healpix_get_neighbours_within_range_radec(ra, dec, radius, healpixes, Nside)

def healpix_distance_to_radec(hp, Nside, ra, dec, closestradec):
    return _util.healpix_distance_to_radec(hp, Nside, ra, dec, closestradec)

def healpix_distance_to_xyz(hp, Nside, xyz, closestxyz):
    return _util.healpix_distance_to_xyz(hp, Nside, xyz, closestxyz)

def healpix_within_range_of_radec(hp, Nside, ra, dec, radius):
    return _util.healpix_within_range_of_radec(hp, Nside, ra, dec, radius)

def healpix_within_range_of_xyz(hp, Nside, xyz, radius):
    return _util.healpix_within_range_of_xyz(hp, Nside, xyz, radius)

def healpix_radec_bounds(hp, nside):
    return _util.healpix_radec_bounds(hp, nside)

def healpix_rangesearch_xyz(xyz, radius, Nside):
    return _util.healpix_rangesearch_xyz(xyz, radius, Nside)

def healpix_rangesearch_xyz_approx(xyz, radius, Nside):
    return _util.healpix_rangesearch_xyz_approx(xyz, radius, Nside)

def healpix_rangesearch_radec_approx(ra, dec, radius, Nside):
    return _util.healpix_rangesearch_radec_approx(ra, dec, radius, Nside)

def healpix_rangesearch_radec(ra, dec, radius, Nside):
    return _util.healpix_rangesearch_radec(ra, dec, radius, Nside)

def healpix_region_search(seed, seeds, Nside, accepted, rejected, accept, token, depth):
    return _util.healpix_region_search(seed, seeds, Nside, accepted, rejected, accept, token, depth)

def healpix_region_searchl(seed, seeds, Nside, accepted, rejected, accept, token, depth):
    return _util.healpix_region_searchl(seed, seeds, Nside, accepted, rejected, accept, token, depth)

def anwcs_wcslib_to_string(wcs):
    return _util.anwcs_wcslib_to_string(wcs)
ANWCS_TYPE_WCSLIB = _util.ANWCS_TYPE_WCSLIB
ANWCS_TYPE_SIP = _util.ANWCS_TYPE_SIP
ANWCS_TYPE_WCSTOOLS = _util.ANWCS_TYPE_WCSTOOLS
class anwcs_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_util.anwcs_t_type_get, _util.anwcs_t_type_set)
    data = property(_util.anwcs_t_data_get, _util.anwcs_t_data_set)

    def __init__(self, fn, ext=0, slen=0):
        _util.anwcs_t_swiginit(self, _util.new_anwcs_t(fn, ext, slen))
    __swig_destroy__ = _util.delete_anwcs_t

    def pixel_scale(self):
        return _util.anwcs_t_pixel_scale(self)

    def get_center(self):
        return _util.anwcs_t_get_center(self)

    def get_radius(self):
        return _util.anwcs_t_get_radius(self)

    def is_inside(self, ra, dec):
        return _util.anwcs_t_is_inside(self, ra, dec)

    def get_width(self):
        return _util.anwcs_t_get_width(self)

    def get_height(self):
        return _util.anwcs_t_get_height(self)

    def set_width(self, W):
        return _util.anwcs_t_set_width(self, W)

    def set_height(self, H):
        return _util.anwcs_t_set_height(self, H)

    def pixelxy2radec(self, x, y):
        return _util.anwcs_t_pixelxy2radec(self, x, y)

    def radec2pixelxy(self, ra, dec):
        return _util.anwcs_t_radec2pixelxy(self, ra, dec)

    def write_to(self, filename):
        return _util.anwcs_t_write_to(self, filename)

# Register anwcs_t in _util:
_util.anwcs_t_swigregister(anwcs_t)


def anwcs_walk_outline(wcs, path, fill):
    return _util.anwcs_walk_outline(wcs, path, fill)

def anwcs_wcslib_from_string(str, len):
    return _util.anwcs_wcslib_from_string(str, len)

def anwcs_open(filename, ext):
    return _util.anwcs_open(filename, ext)

def anwcs_open_wcslib(filename, ext):
    return _util.anwcs_open_wcslib(filename, ext)

def anwcs_open_wcstools(filename, ext):
    return _util.anwcs_open_wcstools(filename, ext)

def anwcs_wcstools_from_string(str, len):
    return _util.anwcs_wcstools_from_string(str, len)

def anwcs_open_sip(filename, ext):
    return _util.anwcs_open_sip(filename, ext)

def anwcs_open_tan(filename, ext):
    return _util.anwcs_open_tan(filename, ext)

def anwcs_new_sip(sip):
    return _util.anwcs_new_sip(sip)

def anwcs_new_tan(tan):
    return _util.anwcs_new_tan(tan)

def anwcs_create_box(ra, dec, width, W, H):
    return _util.anwcs_create_box(ra, dec, width, W, H)

def anwcs_create_box_upsidedown(ra, dec, width, W, H):
    return _util.anwcs_create_box_upsidedown(ra, dec, width, W, H)

def anwcs_create_mercator(refra, refdec, zoomfactor, W, H, yflip):
    return _util.anwcs_create_mercator(refra, refdec, zoomfactor, W, H, yflip)

def anwcs_create_mercator_2(refra, refdec, crpix1, crpix2, zoomfactor, W, H, yflip):
    return _util.anwcs_create_mercator_2(refra, refdec, crpix1, crpix2, zoomfactor, W, H, yflip)

def anwcs_create_mollweide(refra, refdec, zoomfactor, W, H, yflip):
    return _util.anwcs_create_mollweide(refra, refdec, zoomfactor, W, H, yflip)

def anwcs_create_cea_wcs(refra, refdec, refx, refy, pixscale, W, H, yflip):
    return _util.anwcs_create_cea_wcs(refra, refdec, refx, refy, pixscale, W, H, yflip)

def anwcs_galactic_to_radec(wcs):
    return _util.anwcs_galactic_to_radec(wcs)

def anwcs_create_galactic_car_wcs(refra, refdec, refx, refy, pixscale, W, H, yflip):
    return _util.anwcs_create_galactic_car_wcs(refra, refdec, refx, refy, pixscale, W, H, yflip)

def anwcs_create_hammer_aitoff(refra, refdec, zoomfactor, W, H, yflip):
    return _util.anwcs_create_hammer_aitoff(refra, refdec, zoomfactor, W, H, yflip)

def anwcs_create_hammer_aitoff_rectangular(refra, refdec, zoomfactor, rotate, W, H, yflip):
    return _util.anwcs_create_hammer_aitoff_rectangular(refra, refdec, zoomfactor, rotate, W, H, yflip)

def anwcs_create_hammer_aitoff_galactic(ref_long, ref_lat, zoomfactor, W, H, yflip):
    return _util.anwcs_create_hammer_aitoff_galactic(ref_long, ref_lat, zoomfactor, W, H, yflip)

def anwcs_create_allsky_hammer_aitoff(refra, refdec, W, H):
    return _util.anwcs_create_allsky_hammer_aitoff(refra, refdec, W, H)

def anwcs_create_allsky_hammer_aitoff2(refra, refdec, W, H):
    return _util.anwcs_create_allsky_hammer_aitoff2(refra, refdec, W, H)

def anwcs_write(wcs, filename):
    return _util.anwcs_write(wcs, filename)

def anwcs_write_to(wcs, fid):
    return _util.anwcs_write_to(wcs, fid)

def anwcs_add_to_header(wcs, hdr):
    return _util.anwcs_add_to_header(wcs, hdr)

def anwcs_radec2pixelxy(wcs, ra, dec):
    return _util.anwcs_radec2pixelxy(wcs, ra, dec)

def anwcs_pixelxy2radec(wcs, px, py):
    return _util.anwcs_pixelxy2radec(wcs, px, py)

def anwcs_pixelxy2xyz(wcs, px, py):
    return _util.anwcs_pixelxy2xyz(wcs, px, py)

def anwcs_xyz2pixelxy(wcs, xyz, px, py):
    return _util.anwcs_xyz2pixelxy(wcs, xyz, px, py)

def anwcs_radec_is_inside_image(wcs, ra, dec):
    return _util.anwcs_radec_is_inside_image(wcs, ra, dec)

def anwcs_get_cd_matrix(wcs):
    return _util.anwcs_get_cd_matrix(wcs)

def anwcs_get_radec_bounds(wcs, stepsize):
    return _util.anwcs_get_radec_bounds(wcs, stepsize)

def anwcs_print(wcs, fid):
    return _util.anwcs_print(wcs, fid)

def anwcs_print_stdout(wcs):
    return _util.anwcs_print_stdout(wcs)

def anwcs_get_radec_center_and_radius(anwcs):
    return _util.anwcs_get_radec_center_and_radius(anwcs)

def anwcs_walk_image_boundary(wcs, stepsize, callback, token):
    return _util.anwcs_walk_image_boundary(wcs, stepsize, callback, token)

def anwcs_find_discontinuity(wcs, ra1, dec1, ra2, dec2, pra3, pdec3, pra4, pdec4):
    return _util.anwcs_find_discontinuity(wcs, ra1, dec1, ra2, dec2, pra3, pdec3, pra4, pdec4)

def anwcs_is_discontinuous(wcs, ra1, dec1, ra2, dec2):
    return _util.anwcs_is_discontinuous(wcs, ra1, dec1, ra2, dec2)

def anwcs_walk_discontinuity(wcs, ra1, dec1, ra2, dec2, ra3, dec3, ra4, dec4, stepsize, radecs):
    return _util.anwcs_walk_discontinuity(wcs, ra1, dec1, ra2, dec2, ra3, dec3, ra4, dec4, stepsize, radecs)

def anwcs_overlaps(wcs1, wcs2, stepsize):
    return _util.anwcs_overlaps(wcs1, wcs2, stepsize)

def anwcs_imagew(anwcs):
    return _util.anwcs_imagew(anwcs)

def anwcs_imageh(anwcs):
    return _util.anwcs_imageh(anwcs)

def anwcs_set_size(anwcs, W, H):
    return _util.anwcs_set_size(anwcs, W, H)

def anwcs_scale_wcs(anwcs, scale):
    return _util.anwcs_scale_wcs(anwcs, scale)

def anwcs_rotate_wcs(anwcs, angle):
    return _util.anwcs_rotate_wcs(anwcs, angle)

def anwcs_pixel_scale(anwcs):
    return _util.anwcs_pixel_scale(anwcs)

def anwcs_free(wcs):
    return _util.anwcs_free(wcs)

def anwcs_get_sip(wcs):
    return _util.anwcs_get_sip(wcs)

def errors_start_logging_to_string():
    return _util.errors_start_logging_to_string()

def errors_stop_logging_to_string(separator):
    return _util.errors_stop_logging_to_string(separator)

anwcs = anwcs_t
anwcs.imagew = property(anwcs.get_width,  anwcs.set_width,  None, 'image width')
anwcs.imageh = property(anwcs.get_height, anwcs.set_height, None, 'image height')
anwcs.writeto = anwcs.write_to

def anwcs_t_get_shape(self):
    return int(self.get_height()), int(self.get_width())
anwcs_t.get_shape = anwcs_t_get_shape

def anwcs_t_set_shape(self, S):
    H,W = S
    self.set_height(H)
    self.set_width(W)
anwcs_t.set_shape = anwcs_t_set_shape
anwcs_t.shape = property(anwcs_t.get_shape, anwcs_t.set_shape, None, 'image shape')

def anwcs_t_galactic_to_radec(self):
    errors_start_logging_to_string()
    rtn = anwcs_galactic_to_radec(self)
    err = errors_stop_logging_to_string('\n')
    if rtn:
        raise RuntimeError('Failed to convert galactic WCS to RA,Dec: ' + err)
anwcs_t.galactic_to_radec = anwcs_t_galactic_to_radec

# same API as tan_t
anwcs.radec_center = anwcs.get_center
anwcs.radius = anwcs.get_radius

def anwcs_from_string(s):
    return anwcs_t(s, -1, len(s))

def anwcs_get_header_string(self):
    s = anwcs_wcslib_to_string(self)
    return (s +
         'NAXIS   = 2' + ' '*69 +
         'NAXIS1  = % 20i' % self.imagew + ' '*50 +
         'NAXIS2  = % 20i' % self.imageh + ' '*50 +
         'END'+' '*77)
anwcs.getHeaderString = anwcs_get_header_string

def anwcs_radec_bounds(self, stepsize=1000):
    r0,r1,d0,d1 = anwcs_get_radec_bounds(self, stepsize)
    return r0,r1,d0,d1
anwcs.radec_bounds = anwcs_radec_bounds

def anwcs_get_cd(self):
    return anwcs_get_cd_matrix(self)
anwcs.get_cd = anwcs_get_cd


DIM_STARS = _util.DIM_STARS
DIM_XY = _util.DIM_XY
DQMAX = _util.DQMAX
DCMAX = _util.DCMAX

def dimquad2dimcode(dimquad):
    return _util.dimquad2dimcode(dimquad)
ONE_OVER_SIXTY = _util.ONE_OVER_SIXTY
RAD_PER_DEG = _util.RAD_PER_DEG
RAD_PER_ARCMIN = _util.RAD_PER_ARCMIN
RAD_PER_ARCSEC = _util.RAD_PER_ARCSEC
DEG_PER_RAD = _util.DEG_PER_RAD
DEG_PER_ARCMIN = _util.DEG_PER_ARCMIN
DEG_PER_ARCSEC = _util.DEG_PER_ARCSEC
ARCMIN_PER_RAD = _util.ARCMIN_PER_RAD
ARCMIN_PER_DEG = _util.ARCMIN_PER_DEG
ARCMIN_PER_ARCSEC = _util.ARCMIN_PER_ARCSEC
ARCSEC_PER_RAD = _util.ARCSEC_PER_RAD
ARCSEC_PER_DEG = _util.ARCSEC_PER_DEG
ARCSEC_PER_ARCMIN = _util.ARCSEC_PER_ARCMIN

def rad2deg(x):
    return _util.rad2deg(x)

def rad2arcmin(x):
    return _util.rad2arcmin(x)

def rad2arcsec(x):
    return _util.rad2arcsec(x)

def deg2rad(x):
    return _util.deg2rad(x)

def deg2arcmin(x):
    return _util.deg2arcmin(x)

def deg2arcsec(x):
    return _util.deg2arcsec(x)

def arcmin2rad(x):
    return _util.arcmin2rad(x)

def arcmin2deg(x):
    return _util.arcmin2deg(x)

def arcmin2arcsec(x):
    return _util.arcmin2arcsec(x)

def arcsec2rad(x):
    return _util.arcsec2rad(x)

def arcsec2deg(x):
    return _util.arcsec2deg(x)

def arcsec2arcmin(x):
    return _util.arcsec2arcmin(x)
MJD_JD_OFFSET = _util.MJD_JD_OFFSET

def mjdtojd(mjd):
    return _util.mjdtojd(mjd)

def jdtomjd(jd):
    return _util.jdtomjd(jd)

def xy2ra(x, y):
    return _util.xy2ra(x, y)

def z2dec(z):
    return _util.z2dec(z)

def atora(str):
    return _util.atora(str)

def atodec(str):
    return _util.atodec(str)

def mag2flux(mag):
    return _util.mag2flux(mag)

def radecrange2xyzrange(ralow, declow, rahigh, dechigh, xyzlow, xyzhigh):
    return _util.radecrange2xyzrange(ralow, declow, rahigh, dechigh, xyzlow, xyzhigh)

def radec2xyz(ra, dec, x, y, z):
    return _util.radec2xyz(ra, dec, x, y, z)

def xyz2radec(x, y, z):
    return _util.xyz2radec(x, y, z)

def xyzarr2radec(xyz):
    return _util.xyzarr2radec(xyz)

def xyzarr2radecarr(xyz, radec):
    return _util.xyzarr2radecarr(xyz, radec)

def radec2xyzarr(ra, dec):
    return _util.radec2xyzarr(ra, dec)

def radec2xyzarrmany(xyz, n):
    return _util.radec2xyzarrmany(xyz, n)

def radecdeg2xyz(ra, dec, x, y, z):
    return _util.radecdeg2xyz(ra, dec, x, y, z)

def xyzarr2radecdeg(xyz):
    return _util.xyzarr2radecdeg(xyz)

def xyzarr2radecdegarr(xyz, radec):
    return _util.xyzarr2radecdegarr(xyz, radec)

def radecdeg2xyzarr(ra, dec):
    return _util.radecdeg2xyzarr(ra, dec)

def radecdegarr2xyzarr(radec, xyz):
    return _util.radecdegarr2xyzarr(radec, xyz)

def radecdeg2xyzarrmany(xyz, n):
    return _util.radecdeg2xyzarrmany(xyz, n)

def radec_derivatives(ra, dec, dra, ddec):
    return _util.radec_derivatives(ra, dec, dra, ddec)

def distsq_between_radecdeg(ra1, dec1, ra2, dec2):
    return _util.distsq_between_radecdeg(ra1, dec1, ra2, dec2)

def arcsec_between_radecdeg(ra1, dec1, ra2, dec2):
    return _util.arcsec_between_radecdeg(ra1, dec1, ra2, dec2)

def deg_between_radecdeg(ra1, dec1, ra2, dec2):
    return _util.deg_between_radecdeg(ra1, dec1, ra2, dec2)

def ra2mercx(ra):
    return _util.ra2mercx(ra)

def dec2mercy(dec):
    return _util.dec2mercy(dec)

def ra2hms(ra, h, m, s):
    return _util.ra2hms(ra, h, m, s)

def dec2dms(dec, sign, d, m, s):
    return _util.dec2dms(dec, sign, d, m, s)

def hms2ra(h, m, s):
    return _util.hms2ra(h, m, s)

def dms2dec(sgn, d, m, s):
    return _util.dms2dec(sgn, d, m, s)

def ra2hmsstring(ra, str):
    return _util.ra2hmsstring(ra, str)

def dec2dmsstring(dec, str):
    return _util.dec2dmsstring(dec, str)

def project_hammer_aitoff_x(x, y, z, projx, projy):
    return _util.project_hammer_aitoff_x(x, y, z, projx, projy)

def project_equal_area(x, y, z, projx, projy):
    return _util.project_equal_area(x, y, z, projx, projy)

def distsq2arc(dist2):
    return _util.distsq2arc(dist2)

def distsq2rad(dist2):
    return _util.distsq2rad(dist2)

def distsq2deg(dist2):
    return _util.distsq2deg(dist2)

def dist2rad(dist):
    return _util.dist2rad(dist)

def distsq2arcsec(dist2):
    return _util.distsq2arcsec(dist2)

def dist2arcsec(dist):
    return _util.dist2arcsec(dist)

def rad2distsq(arcInRadians):
    return _util.rad2distsq(arcInRadians)

def rad2dist(arcInRadians):
    return _util.rad2dist(arcInRadians)

def arcsec2distsq(arcInArcSec):
    return _util.arcsec2distsq(arcInArcSec)

def arcsec2dist(arcInArcSec):
    return _util.arcsec2dist(arcInArcSec)

def deg2dist(arcInDegrees):
    return _util.deg2dist(arcInDegrees)

def deg2distsq(d):
    return _util.deg2distsq(d)

def arcmin2dist(arcmin):
    return _util.arcmin2dist(arcmin)

def arcmin2distsq(arcmin):
    return _util.arcmin2distsq(arcmin)

def dist2deg(dist):
    return _util.dist2deg(dist)
HELP_ERR = _util.HELP_ERR
OPT_ERR = _util.OPT_ERR

def make_rand_star(star, ramin, ramax, decmin, decmax):
    return _util.make_rand_star(star, ramin, ramax, decmin, decmax)

def star_coords(s, r, tangent, x, y):
    return _util.star_coords(s, r, tangent, x, y)

def star_midpoint(mid, A, B):
    return _util.star_midpoint(mid, A, B)

def qfits_header_debug_dump(arg1):
    return _util.qfits_header_debug_dump(arg1)

def qfits_header_list(hdr, out):
    return _util.qfits_header_list(hdr, out)

def qfits_header_new():
    return _util.qfits_header_new()

def qfits_header_default():
    return _util.qfits_header_default()

def qfits_header_n(arg1):
    return _util.qfits_header_n(arg1)

def qfits_header_add(arg1, arg2, arg3, arg4, arg5):
    return _util.qfits_header_add(arg1, arg2, arg3, arg4, arg5)

def qfits_header_add_after(arg1, arg2, arg3, arg4, arg5, arg6):
    return _util.qfits_header_add_after(arg1, arg2, arg3, arg4, arg5, arg6)

def qfits_header_append(arg1, arg2, arg3, arg4, arg5):
    return _util.qfits_header_append(arg1, arg2, arg3, arg4, arg5)

def qfits_header_del(arg1, arg2):
    return _util.qfits_header_del(arg1, arg2)

def qfits_header_sort(arg1):
    return _util.qfits_header_sort(arg1)

def qfits_header_copy(arg1):
    return _util.qfits_header_copy(arg1)

def qfits_header_mod(arg1, arg2, arg3, arg4):
    return _util.qfits_header_mod(arg1, arg2, arg3, arg4)

def qfits_header_destroy(arg1):
    return _util.qfits_header_destroy(arg1)

def qfits_header_getstr(arg1, arg2):
    return _util.qfits_header_getstr(arg1, arg2)

def qfits_header_getstr_pretty(hdr, key, pretty, default_val):
    return _util.qfits_header_getstr_pretty(hdr, key, pretty, default_val)

def qfits_header_getitem(arg1, arg2, arg3, arg4, arg5, arg6):
    return _util.qfits_header_getitem(arg1, arg2, arg3, arg4, arg5, arg6)

def qfits_header_setitem(arg1, arg2, key, val, comment, line):
    return _util.qfits_header_setitem(arg1, arg2, key, val, comment, line)

def qfits_header_getcom(arg1, arg2):
    return _util.qfits_header_getcom(arg1, arg2)

def qfits_header_getint(arg1, arg2, arg3):
    return _util.qfits_header_getint(arg1, arg2, arg3)

def qfits_header_getdouble(arg1, arg2, arg3):
    return _util.qfits_header_getdouble(arg1, arg2, arg3)

def qfits_header_getboolean(arg1, arg2, arg3):
    return _util.qfits_header_getboolean(arg1, arg2, arg3)

def qfits_header_dump(arg1, arg2):
    return _util.qfits_header_dump(arg1, arg2)

def qfits_header_findmatch(hdr, key):
    return _util.qfits_header_findmatch(hdr, key)

def qfits_header_write_line(hdr, line, result):
    return _util.qfits_header_write_line(hdr, line, result)

def qfits_header_read_hdr_string(arg1):
    return _util.qfits_header_read_hdr_string(arg1)

def qfits_zeropad(arg1):
    return _util.qfits_zeropad(arg1)

def qfits_is_fits(arg1):
    return _util.qfits_is_fits(arg1)

def is_blank_line(s):
    return _util.is_blank_line(s)

def fitsio_to_qfits_header(hdr):
    hdrstr = ''
    for rec in hdr.records():
        cardstr = rec.get('card', None)
        if cardstr is None:
            cardstr = rec.get('card_string', None)
        if cardstr is None:
            cardstr = hdr._record2card(rec)
# pad
        cardstr = cardstr + ' '*(80 - len(cardstr))
        hdrstr += cardstr
    hdrstr += 'END' + ' '*77
    qhdr = qfits_header_read_hdr_string(hdrstr)
    return qhdr


def wcs_pv2sip_header(hdr, xy, Nxy, stepsize, xlo, xhi, ylo, yhi, imageW, imageH, order, forcetan, doshift):
    return _util.wcs_pv2sip_header(hdr, xy, Nxy, stepsize, xlo, xhi, ylo, yhi, imageW, imageH, order, forcetan, doshift)

def wcs_pv2sip(wcsinfn, ext, wcsoutfn, scamp_head_file, xy, Nxy, stepsize, xlo, xhi, ylo, yhi, imageW, imageH, order, forcetan, doshift):
    return _util.wcs_pv2sip(wcsinfn, ext, wcsoutfn, scamp_head_file, xy, Nxy, stepsize, xlo, xhi, ylo, yhi, imageW, imageH, order, forcetan, doshift)

def wcs_pv2sip_hdr(hdr, order=5, xlo=0, xhi=0, ylo=0, yhi=0,
                   stepsize=0, W=0, H=0):
    qhdr = fitsio_to_qfits_header(hdr)
    forcetan = False
    doshift = 1
    scamp = False

    sip = wcs_pv2sip_header(qhdr, None, 0, stepsize, xlo, xhi, ylo, yhi, W, H,
                            order, forcetan, doshift)
    return sip

SIP_MAXORDER = _util.SIP_MAXORDER
class tan_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    crval = property(_util.tan_t_crval_get, _util.tan_t_crval_set)
    crpix = property(_util.tan_t_crpix_get, _util.tan_t_crpix_set)
    cd = property(_util.tan_t_cd_get, _util.tan_t_cd_set)
    imagew = property(_util.tan_t_imagew_get, _util.tan_t_imagew_set)
    imageh = property(_util.tan_t_imageh_get, _util.tan_t_imageh_set)
    sin = property(_util.tan_t_sin_get, _util.tan_t_sin_set)

    def __init__(self, *args):
        _util.tan_t_swiginit(self, _util.new_tan_t(*args))
    __swig_destroy__ = _util.delete_tan_t

    def set(self, crval1, crval2, crpix1, crpix2, cd11, cd12, cd21, cd22, imagew, imageh):
        return _util.tan_t_set(self, crval1, crval2, crpix1, crpix2, cd11, cd12, cd21, cd22, imagew, imageh)

    def is_inside(self, ra, dec):
        return _util.tan_t_is_inside(self, ra, dec)

    def scale(self, factor):
        return _util.tan_t_scale(self, factor)

    def rotate(self, angle_deg):
        return _util.tan_t_rotate(self, angle_deg)

    def get_width(self):
        return _util.tan_t_get_width(self)

    def get_height(self):
        return _util.tan_t_get_height(self)

    def set_width(self, x):
        return _util.tan_t_set_width(self, x)

    def set_height(self, x):
        return _util.tan_t_set_height(self, x)

    def pixel_scale(self):
        return _util.tan_t_pixel_scale(self)

    def radec_center(self):
        return _util.tan_t_radec_center(self)

    def radius(self):
        return _util.tan_t_radius(self)

    def xyzcenter(self):
        return _util.tan_t_xyzcenter(self)

    def pixelxy2xyz(self, x, y):
        return _util.tan_t_pixelxy2xyz(self, x, y)

    def pixelxy2radec(self, x, y):
        return _util.tan_t_pixelxy2radec(self, x, y)

    def radec2pixelxy(self, ra, dec):
        return _util.tan_t_radec2pixelxy(self, ra, dec)

    def iwc2pixelxy(self, u, v):
        return _util.tan_t_iwc2pixelxy(self, u, v)

    def pixelxy2iwc(self, x, y):
        return _util.tan_t_pixelxy2iwc(self, x, y)

    def iwc2radec(self, u, v):
        return _util.tan_t_iwc2radec(self, u, v)

    def radec2iwc(self, ra, dec):
        return _util.tan_t_radec2iwc(self, ra, dec)

    def xyz2pixelxy(self, x, y, z):
        return _util.tan_t_xyz2pixelxy(self, x, y, z)

    def write_to(self, filename):
        return _util.tan_t_write_to(self, filename)

    def set_crval(self, ra, dec):
        return _util.tan_t_set_crval(self, ra, dec)

    def set_crpix(self, x, y):
        return _util.tan_t_set_crpix(self, x, y)

    def set_cd(self, cd11, cd12, cd21, cd22):
        return _util.tan_t_set_cd(self, cd11, cd12, cd21, cd22)

    def set_imagesize(self, w, h):
        return _util.tan_t_set_imagesize(self, w, h)

# Register tan_t in _util:
_util.tan_t_swigregister(tan_t)

class sip_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    wcstan = property(_util.sip_t_wcstan_get, _util.sip_t_wcstan_set)
    a_order = property(_util.sip_t_a_order_get, _util.sip_t_a_order_set)
    b_order = property(_util.sip_t_b_order_get, _util.sip_t_b_order_set)
    a = property(_util.sip_t_a_get, _util.sip_t_a_set)
    b = property(_util.sip_t_b_get, _util.sip_t_b_set)
    ap_order = property(_util.sip_t_ap_order_get, _util.sip_t_ap_order_set)
    bp_order = property(_util.sip_t_bp_order_get, _util.sip_t_bp_order_set)
    ap = property(_util.sip_t_ap_get, _util.sip_t_ap_set)
    bp = property(_util.sip_t_bp_get, _util.sip_t_bp_set)

    def __init__(self, *args):
        _util.sip_t_swiginit(self, _util.new_sip_t(*args))
    __swig_destroy__ = _util.delete_sip_t

    def get_subimage(self, x0, y0, w, h):
        return _util.sip_t_get_subimage(self, x0, y0, w, h)

    def scale(self, factor):
        return _util.sip_t_scale(self, factor)

    def pixel_scale(self):
        return _util.sip_t_pixel_scale(self)

    def radec_center(self):
        return _util.sip_t_radec_center(self)

    def radius(self):
        return _util.sip_t_radius(self)

    def write_to(self, filename):
        return _util.sip_t_write_to(self, filename)

    def ensure_inverse_polynomials(self):
        return _util.sip_t_ensure_inverse_polynomials(self)

    def pixelxy2xyz(self, x, y):
        return _util.sip_t_pixelxy2xyz(self, x, y)

    def pixelxy2radec(self, x, y):
        return _util.sip_t_pixelxy2radec(self, x, y)

    def radec2pixelxy(self, ra, dec):
        return _util.sip_t_radec2pixelxy(self, ra, dec)

    def iwc2pixelxy(self, u, v):
        return _util.sip_t_iwc2pixelxy(self, u, v)

    def pixelxy2iwc(self, x, y):
        return _util.sip_t_pixelxy2iwc(self, x, y)

    def iwc2radec(self, u, v):
        return _util.sip_t_iwc2radec(self, u, v)

    def radec2iwc(self, ra, dec):
        return _util.sip_t_radec2iwc(self, ra, dec)

    def xyz2pixelxy(self, x, y, z):
        return _util.sip_t_xyz2pixelxy(self, x, y, z)

    def is_inside(self, ra, dec):
        return _util.sip_t_is_inside(self, ra, dec)

    def set_a_term(self, i, j, val):
        return _util.sip_t_set_a_term(self, i, j, val)

    def set_b_term(self, i, j, val):
        return _util.sip_t_set_b_term(self, i, j, val)

    def set_ap_term(self, i, j, val):
        return _util.sip_t_set_ap_term(self, i, j, val)

    def set_bp_term(self, i, j, val):
        return _util.sip_t_set_bp_term(self, i, j, val)

    def get_a_term(self, i, j):
        return _util.sip_t_get_a_term(self, i, j)

    def get_b_term(self, i, j):
        return _util.sip_t_get_b_term(self, i, j)

    def get_ap_term(self, i, j):
        return _util.sip_t_get_ap_term(self, i, j)

    def get_bp_term(self, i, j):
        return _util.sip_t_get_bp_term(self, i, j)

    def set_width(self, x):
        return _util.sip_t_set_width(self, x)

    def set_height(self, x):
        return _util.sip_t_set_height(self, x)

    def get_width(self):
        return _util.sip_t_get_width(self)

    def get_height(self):
        return _util.sip_t_get_height(self)

    def get_distortion(self, x, y):
        return _util.sip_t_get_distortion(self, x, y)

    def get_undistortion(self, x, y):
        return _util.sip_t_get_undistortion(self, x, y)

# Register sip_t in _util:
_util.sip_t_swigregister(sip_t)


def sip_create():
    return _util.sip_create()

def sip_free(sip):
    return _util.sip_free(sip)

def sip_copy(dest, src):
    return _util.sip_copy(dest, src)

def sip_wrap_tan(tan, sip):
    return _util.sip_wrap_tan(tan, sip)

def sip_imagew(sip):
    return _util.sip_imagew(sip)

def sip_imageh(sip):
    return _util.sip_imageh(sip)

def sip_pixelxy2radec(sip, px, py, a, d):
    return _util.sip_pixelxy2radec(sip, px, py, a, d)

def sip_pixelxy2xyzarr(sip, px, py, xyz):
    return _util.sip_pixelxy2xyzarr(sip, px, py, xyz)

def sip_radec2pixelxy(sip, a, d, px, py):
    return _util.sip_radec2pixelxy(sip, a, d, px, py)

def sip_radec2pixelxy_check(sip, ra, dec, px, py):
    return _util.sip_radec2pixelxy_check(sip, ra, dec, px, py)

def sip_xyzarr2pixelxy(sip, xyz, px, py):
    return _util.sip_xyzarr2pixelxy(sip, xyz, px, py)

def sip_xyz2pixelxy(sip, x, y, z, px, py):
    return _util.sip_xyz2pixelxy(sip, x, y, z, px, py)

def sip_pixelxy2iwc(sip, px, py, iwcx, iwcy):
    return _util.sip_pixelxy2iwc(sip, px, py, iwcx, iwcy)

def tan_det_cd(tan):
    return _util.tan_det_cd(tan)

def sip_det_cd(sip):
    return _util.sip_det_cd(sip)

def tan_pixel_scale(tn):
    return _util.tan_pixel_scale(tn)

def sip_pixel_scale(sip):
    return _util.sip_pixel_scale(sip)

def sip_calc_inv_distortion(sip, U, V, u, v):
    return _util.sip_calc_inv_distortion(sip, U, V, u, v)

def sip_calc_distortion(sip, u, v, U, V):
    return _util.sip_calc_distortion(sip, u, v, U, V)

def sip_pixel_distortion(sip, x, y):
    return _util.sip_pixel_distortion(sip, x, y)

def sip_pixel_undistortion(sip, x, y):
    return _util.sip_pixel_undistortion(sip, x, y)

def tan_pixelxy2xyzarr(tan, px, py, xyz):
    return _util.tan_pixelxy2xyzarr(tan, px, py, xyz)

def tan_pixelxy2radec(wcs_tan, px, py):
    return _util.tan_pixelxy2radec(wcs_tan, px, py)

def tan_pixelxy2radecarr(wcs_tan, px, py, radec):
    return _util.tan_pixelxy2radecarr(wcs_tan, px, py, radec)

def tan_radec2pixelxy(wcs_tan, ra, dec, px, py):
    return _util.tan_radec2pixelxy(wcs_tan, ra, dec, px, py)

def tan_xyzarr2pixelxy(wcs_tan, xyz, px, py):
    return _util.tan_xyzarr2pixelxy(wcs_tan, xyz, px, py)

def tan_iwc2pixelxy(tan, iwcx, iwcy, px, py):
    return _util.tan_iwc2pixelxy(tan, iwcx, iwcy, px, py)

def tan_iwc2xyzarr(tan, x, y, xyz):
    return _util.tan_iwc2xyzarr(tan, x, y, xyz)

def tan_iwc2radec(tan, x, y):
    return _util.tan_iwc2radec(tan, x, y)

def tan_pixelxy2iwc(tan, px, py, iwcx, iwcy):
    return _util.tan_pixelxy2iwc(tan, px, py, iwcx, iwcy)

def tan_xyzarr2iwc(tan, xyz, iwcx, iwcy):
    return _util.tan_xyzarr2iwc(tan, xyz, iwcx, iwcy)

def tan_radec2iwc(tan, ra, dec, iwcx, iwcy):
    return _util.tan_radec2iwc(tan, ra, dec, iwcx, iwcy)

def sip_xyzarr2iwc(sip, xyz, iwcx, iwcy):
    return _util.sip_xyzarr2iwc(sip, xyz, iwcx, iwcy)

def sip_radec2iwc(sip, ra, dec, iwcx, iwcy):
    return _util.sip_radec2iwc(sip, ra, dec, iwcx, iwcy)

def sip_iwc2pixelxy(sip, iwcx, iwcy, px, py):
    return _util.sip_iwc2pixelxy(sip, iwcx, iwcy, px, py)

def sip_iwc2radec(sip, x, y):
    return _util.sip_iwc2radec(sip, x, y)

def sip_print(arg1):
    return _util.sip_print(arg1)

def sip_print_to(arg1, fid):
    return _util.sip_print_to(arg1, fid)

def tan_print(tan):
    return _util.tan_print(tan)

def tan_print_to(tan, f):
    return _util.tan_print_to(tan, f)

def sip_get_crval(sip):
    return _util.sip_get_crval(sip)

def tan_get_orientation(tan):
    return _util.tan_get_orientation(tan)

def sip_get_orientation(sip):
    return _util.sip_get_orientation(sip)

def sip_get_image_size(hdr, pW, pH):
    return _util.sip_get_image_size(hdr, pW, pH)

def sip_read_tan_or_sip_header_file_ext(fn, ext, dest, forcetan):
    return _util.sip_read_tan_or_sip_header_file_ext(fn, ext, dest, forcetan)

def sip_create_header(sip):
    return _util.sip_create_header(sip)

def tan_create_header(tan):
    return _util.tan_create_header(tan)

def sip_add_to_header(hdr, sip):
    return _util.sip_add_to_header(hdr, sip)

def tan_add_to_header(hdr, tan):
    return _util.tan_add_to_header(hdr, tan)

def sip_read_header_file(fn, dest):
    return _util.sip_read_header_file(fn, dest)

def sip_read_header_file_ext(fn, ext, dest):
    return _util.sip_read_header_file_ext(fn, ext, dest)

def sip_read_header_file_ext_only(fn, ext, dest):
    return _util.sip_read_header_file_ext_only(fn, ext, dest)

def tan_read_header_file(fn, dest):
    return _util.tan_read_header_file(fn, dest)

def tan_read_header_file_ext(fn, ext, dest):
    return _util.tan_read_header_file_ext(fn, ext, dest)

def tan_read_header_file_ext_only(fn, ext, dest):
    return _util.tan_read_header_file_ext_only(fn, ext, dest)

def sip_read_header(hdr, dest):
    return _util.sip_read_header(hdr, dest)

def tan_read_header(hdr, dest):
    return _util.tan_read_header(hdr, dest)

def sip_from_string(str, len, dest):
    return _util.sip_from_string(str, len, dest)

def tan_write_to(tan, fid):
    return _util.tan_write_to(tan, fid)

def sip_write_to(sip, fid):
    return _util.sip_write_to(sip, fid)

def sip_write_to_file(sip, fn):
    return _util.sip_write_to_file(sip, fn)

def tan_write_to_file(tan, fn):
    return _util.tan_write_to_file(tan, fn)

def wcs_pixel_center_for_size(size):
    return _util.wcs_pixel_center_for_size(size)

def sip_ensure_inverse_polynomials(sip):
    return _util.sip_ensure_inverse_polynomials(sip)

def sip_compute_inverse_polynomials(sip, NX, NY, xlo, xhi, ylo, yhi):
    return _util.sip_compute_inverse_polynomials(sip, NX, NY, xlo, xhi, ylo, yhi)

def sip_filter_stars_in_field(sip, tan, xyz, radec, N, xy, inds, Ngood):
    return _util.sip_filter_stars_in_field(sip, tan, xyz, radec, N, xy, inds, Ngood)

def sip_get_radec_bounds(wcs, stepsize):
    return _util.sip_get_radec_bounds(wcs, stepsize)

def sip_walk_image_boundary(wcs, stepsize, callback, token):
    return _util.sip_walk_image_boundary(wcs, stepsize, callback, token)

def sip_get_radec_center(wcs):
    return _util.sip_get_radec_center(wcs)

def tan_get_radec_center(wcs):
    return _util.tan_get_radec_center(wcs)

def sip_get_radius_deg(wcs):
    return _util.sip_get_radius_deg(wcs)

def tan_get_radius_deg(wcs):
    return _util.tan_get_radius_deg(wcs)

def sip_get_radec_center_hms(wcs, rah, ram, ras, decsign, decd, decm, decs):
    return _util.sip_get_radec_center_hms(wcs, rah, ram, ras, decsign, decd, decm, decs)

def sip_pixel_is_inside_image(wcs, px, py):
    return _util.sip_pixel_is_inside_image(wcs, px, py)

def sip_is_inside_image(wcs, ra, dec):
    return _util.sip_is_inside_image(wcs, ra, dec)

def sip_get_radec_center_hms_string(wcs, rastr, decstr):
    return _util.sip_get_radec_center_hms_string(wcs, rastr, decstr)

def sip_get_field_size(wcs, pw, ph, units):
    return _util.sip_get_field_size(wcs, pw, ph, units)

def sip_shift(sipin, sipout, xlo, xhi, ylo, yhi):
    return _util.sip_shift(sipin, sipout, xlo, xhi, ylo, yhi)

def tan_pixel_is_inside_image(wcs, px, py):
    return _util.tan_pixel_is_inside_image(wcs, px, py)

def tan_is_inside_image(wcs, ra, dec):
    return _util.tan_is_inside_image(wcs, ra, dec)

def tan_transform(tanin, tanout, xlo, xhi, ylo, yhi, scale):
    return _util.tan_transform(tanin, tanout, xlo, xhi, ylo, yhi, scale)

def tan_scale(tanin, tanout, scale):
    return _util.tan_scale(tanin, tanout, scale)

def sip_scale(tanin, tanout, scale):
    return _util.sip_scale(tanin, tanout, scale)

def tan_rotate(tanin, tanout, rotate):
    return _util.tan_rotate(tanin, tanout, rotate)


def sip_t_tostring(self):
    tan = self.wcstan
    ct = 'SIN' if tan.sin else 'TAN'
    return (('SIP(%s): crpix (%.1f, %.1f), crval (%g, %g), cd (%g, %g, %g, %g), '
             + 'image %g x %g; SIP orders A=%i, B=%i, AP=%i, BP=%i') %
            (ct, tan.crpix[0], tan.crpix[1], tan.crval[0], tan.crval[1],
             tan.cd[0], tan.cd[1], tan.cd[2], tan.cd[3],
             tan.imagew, tan.imageh, self.a_order, self.b_order,
             self.ap_order, self.bp_order))
sip_t.__str__ = sip_t_tostring

def sip_t_addtoheader(self, hdr):
    '''Adds this SIP WCS header to the given fitsio header'''
    self.wcstan.add_to_header(hdr)
    hdr.delete('CTYPE1')
    hdr.delete('CTYPE2')
    for k,v,c in [
        ('CTYPE1', 'RA---TAN-SIP', 'TANgent plane+SIP'),
        ('CTYPE2', 'DEC--TAN-SIP', 'TANgent plane+SIP'),
        ('A_ORDER', self.a_order, 'Polynomial order, axis 1'),
        ('B_ORDER', self.b_order, 'Polynomial order, axis 2'),
        ('AP_ORDER', self.ap_order, 'Inv.polynomial order, axis 1'),
        ('BP_ORDER', self.bp_order, 'Inv.polynomial order, axis 2'),
        ]:
        hdr.add_record(dict(name=k, value=v, comment=c))
    for i in range(self.a_order + 1):
        for j in range(self.a_order + 1):
#if i + j < 1:
# drop linear (CD) terms
            if i + j < 2:
                continue
            if i + j > self.a_order:
                continue
            hdr.add_record(dict(name='A_%i_%i' % (i,j), value=self.get_a_term(i, j),
                                comment='SIP polynomial term'))
    for i in range(self.b_order + 1):
        for j in range(self.b_order + 1):
#if i + j < 1:
# drop linear (CD) terms
            if i + j < 2:
                continue
            if i + j > self.b_order:
                continue
            hdr.add_record(dict(name='B_%i_%i' % (i,j), value=self.get_b_term(i, j),
                                comment='SIP polynomial term'))
    for i in range(self.ap_order + 1):
        for j in range(self.ap_order + 1):
            if i + j < 1:
                continue
            if i + j > self.ap_order:
                continue
            hdr.add_record(dict(name='AP_%i_%i' % (i,j), value=self.get_ap_term(i, j),
                                comment='SIP polynomial term'))
    for i in range(self.bp_order + 1):
        for j in range(self.bp_order + 1):
            if i + j < 1:
                continue
            if i + j > self.bp_order:
                continue
            hdr.add_record(dict(name='BP_%i_%i' % (i,j), value=self.get_bp_term(i, j),
                                comment='SIP polynomial term'))
sip_t.add_to_header = sip_t_addtoheader


# def sip_t_get_subimage(self, x0, y0, w, h):
#     wcs2 = sip_t(self)
#     cpx,cpy = wcs2.crpix
#     wcs2.set_crpix((cpx - x0, cpy - y0))
#     wcs2.set_width(float(w))
#     wcs2.set_height(float(h))
#     return wcs2
# sip_t.get_subimage = sip_t_get_subimage

def sip_t_get_shape(self):
    return (self.wcstan.imageh, self.wcstan.imagew)
sip_t.get_shape = sip_t_get_shape

def sip_t_set_shape(self, S):
    H,W = S
    self.set_height(H)
    self.set_width(W)
sip_t.set_shape = sip_t_set_shape

sip_t.imagew = property(sip_t.get_width,  sip_t.set_width,  None, 'image width')
sip_t.imageh = property(sip_t.get_height, sip_t.set_height, None, 'image height')
sip_t.shape = property(sip_t.get_shape, sip_t.set_shape, None, 'image shape')

def sip_t_get_cd(self):
    cd = self.wcstan.cd
    return (cd[0], cd[1], cd[2], cd[3])
def sip_t_set_cd(self, x):
    self.wcstan.cd = x
sip_t.get_cd = sip_t_get_cd
sip_t.set_cd = sip_t_set_cd

def sip_t_get_crval(self):
    return self.wcstan.crval
def sip_t_set_crval(self, x):
    self.wcstan.crval = x
sip_t.get_crval = sip_t_get_crval
sip_t.set_crval = sip_t_set_crval

def sip_t_get_crpix(self):
    return self.wcstan.crpix
def sip_t_set_crpix(self, x):
    self.wcstan.crpix = x
sip_t.get_crpix = sip_t_get_crpix
sip_t.set_crpix = sip_t_set_crpix

sip_t.crval = property(sip_t_get_crval, sip_t_set_crval, None, 'CRVAL')
sip_t.crpix = property(sip_t_get_crpix, sip_t_set_crpix, None, 'CRPIX')
sip_t.cd    = property(sip_t_get_cd   , sip_t_set_cd,    None, 'CD')


def sip_t_radec_bounds(self):
# W,H = self.wcstan.imagew, self.wcstan.imageh
# r,d = self.pixelxy2radec([1, W, W, 1], [1, 1, H, H])
# return (r.min(), r.max(), d.min(), d.max())
    W,H = self.imagew, self.imageh
    r,d = self.pixelxy2radec([1, W/2, W, W, W, W/2, 1, 1], [1, 1, 1, H/2, H, H, H, H/2])
    rx = r.max()
    rn = r.min()
# ugh, RA wrap-around.  We find the largest value < 180 (ie, near zero) and smallest value > 180 (ie, near 360)
# and report them with ralo > rahi so that this case can be identified
    if rx - rn > 180:
        rx = r[r < 180].max()
        rn = r[r > 180].min()
    return (rn, rx, d.min(), d.max())
sip_t.radec_bounds = sip_t_radec_bounds

#def sip_t_fromstring(s):
#   sip = sip_from_string(s, len(s),

_real_sip_t_init = sip_t.__init__
def my_sip_t_init(self, *args, **kwargs):
# fitsio header: check for '.records()' function.
    if len(args) == 1 and hasattr(args[0], 'records'):
        try:
            hdr = args[0]
            qhdr = fitsio_to_qfits_header(hdr)
            args = [qhdr]
        except:
            pass

    _real_sip_t_init(self, *args, **kwargs)
    if self.this is None:
        raise RuntimeError('Duck punch!')
sip_t.__init__ = my_sip_t_init


Sip = sip_t


def coadd_add_numpy(c, py_img, py_weight, fweight, wcs):
    return _util.coadd_add_numpy(c, py_img, py_weight, fweight, wcs)

def coadd_get_snapshot_numpy(co, badpix):
    return _util.coadd_get_snapshot_numpy(co, badpix)

def fit_sip_wcs_py(py_starxyz, py_fieldxy, py_weights, tanin, sip_order, inv_order):
    return _util.fit_sip_wcs_py(py_starxyz, py_fieldxy, py_weights, tanin, sip_order, inv_order)

def broadcast_2to2ok(func, baton, in1, in2):
    return _util.broadcast_2to2ok(func, baton, in1, in2)

def broadcast_2to2(func, baton, in1, in2):
    return _util.broadcast_2to2(func, baton, in1, in2)

def broadcast_2to2i(func, baton, in1, in2):
    return _util.broadcast_2to2i(func, baton, in1, in2)

def tan_rd2xy_wrapper(wcs, in1, in2):
    return _util.tan_rd2xy_wrapper(wcs, in1, in2)

def sip_rd2xy_wrapper(wcs, in1, in2):
    return _util.sip_rd2xy_wrapper(wcs, in1, in2)

def anwcs_rd2xy_wrapper(wcs, in1, in2):
    return _util.anwcs_rd2xy_wrapper(wcs, in1, in2)

def tan_iwc2xy_wrapper(wcs, in1, in2):
    return _util.tan_iwc2xy_wrapper(wcs, in1, in2)

def sip_iwc2xy_wrapper(wcs, in1, in2):
    return _util.sip_iwc2xy_wrapper(wcs, in1, in2)

def tan_xy2iwc_wrapper(wcs, in1, in2):
    return _util.tan_xy2iwc_wrapper(wcs, in1, in2)

def sip_xy2iwc_wrapper(wcs, in1, in2):
    return _util.sip_xy2iwc_wrapper(wcs, in1, in2)

def tan_iwc2rd_wrapper(wcs, in1, in2):
    return _util.tan_iwc2rd_wrapper(wcs, in1, in2)

def sip_iwc2rd_wrapper(wcs, in1, in2):
    return _util.sip_iwc2rd_wrapper(wcs, in1, in2)

def tan_rd2iwc_wrapper(wcs, in1, in2):
    return _util.tan_rd2iwc_wrapper(wcs, in1, in2)

def sip_rd2iwc_wrapper(wcs, in1, in2):
    return _util.sip_rd2iwc_wrapper(wcs, in1, in2)

def tan_xy2rd_wrapper(wcs, in1, in2):
    return _util.tan_xy2rd_wrapper(wcs, in1, in2)

def sip_xy2rd_wrapper(wcs, in1, in2):
    return _util.sip_xy2rd_wrapper(wcs, in1, in2)

def anwcs_xy2rd_wrapper(wcs, in1, in2):
    return _util.anwcs_xy2rd_wrapper(wcs, in1, in2)

def tan_wcs_resample(inwcs, outwcs, py_inimg, py_outimg, weighted, lorder):
    return _util.tan_wcs_resample(inwcs, outwcs, py_inimg, py_outimg, weighted, lorder)

def tan_numpy_xyz2pixelxy(tan, npxyz, npx, npy):
    return _util.tan_numpy_xyz2pixelxy(tan, npxyz, npx, npy)

def an_tally(py_counts, py_x, py_y):
    return _util.an_tally(py_counts, py_x, py_y)

import numpy as np

def tan_t_tostring(self):
    ct = 'SIN' if self.sin else 'TAN'
    return ('%s: crpix (%.1f, %.1f), crval (%g, %g), cd (%g, %g, %g, %g), image %g x %g' %
            (ct, self.crpix[0], self.crpix[1], self.crval[0], self.crval[1],
             self.cd[0], self.cd[1], self.cd[2], self.cd[3],
             self.imagew, self.imageh))
tan_t.__str__ = tan_t_tostring

def tan_t_addtoheader(self, hdr):
    '''Adds this TAN WCS header to the given fitsio header'''
    hdr.add_record(dict(name='CTYPE1', value='RA---TAN', comment='TANgent plane'))
    hdr.add_record(dict(name='CTYPE2', value='DEC--TAN', comment='TANgent plane'))
    hdr.add_record(dict(name='CRVAL1', value=self.crval[0], comment='Reference RA'))
    hdr.add_record(dict(name='CRVAL2', value=self.crval[1], comment='Reference Dec'))
    hdr.add_record(dict(name='CRPIX1', value=self.crpix[0], comment='Reference x'))
    hdr.add_record(dict(name='CRPIX2', value=self.crpix[1], comment='Reference y'))
    hdr.add_record(dict(name='CD1_1', value=self.cd[0], comment='CD matrix'))
    hdr.add_record(dict(name='CD1_2', value=self.cd[1], comment='CD matrix'))
    hdr.add_record(dict(name='CD2_1', value=self.cd[2], comment='CD matrix'))
    hdr.add_record(dict(name='CD2_2', value=self.cd[3], comment='CD matrix'))
    hdr.add_record(dict(name='IMAGEW', value=int(self.imagew), comment='Image width'))
    hdr.add_record(dict(name='IMAGEH', value=int(self.imageh), comment='Image height'))
tan_t.add_to_header = tan_t_addtoheader

## picklable?
def tan_t_getstate(self):
    return (self.crpix[0], self.crpix[1], self.crval[0], self.crval[1],
            self.cd[0], self.cd[1], self.cd[2], self.cd[3],
            self.imagew, self.imageh, self.sin)
def tan_t_setstate(self, state):
#print 'setstate: self', self, 'state', state
#print 'state', state
    self.this = _util.new_tan_t()
#print 'self', repr(self)
    p0,p1,v0,v1,cd0,cd1,cd2,cd3,w,h,sin = state
    self.set_crpix(p0,p1)
    self.set_crval(v0,v1)
    self.set_cd(cd0,cd1,cd2,cd3)
    self.set_imagesize(w,h)
    self.sin = sin
#(self.crpix[0], self.crpix[1], self.crval[0], self.crval[1],
#self.cd[0], self.cd[1], self.cd[2], self.cd[3],
#self.imagew, self.imageh) = state
def tan_t_getnewargs(self):
    return ()
tan_t.__getstate__ = tan_t_getstate
tan_t.__setstate__ = tan_t_setstate
tan_t.__getnewargs__ = tan_t_getnewargs

def tan_t_getshape(self):
    return int(self.imageh), int(self.imagew)

tan_t.shape = property(tan_t_getshape)

def tan_t_get_cd(self):
    cd = self.cd
    return (cd[0], cd[1], cd[2], cd[3])
tan_t.get_cd = tan_t_get_cd

def tan_t_pixelxy2radec(self, x, y):
    return tan_xy2rd_wrapper(self.this, x, y)
tan_t.pixelxy2radec_single = tan_t.pixelxy2radec
tan_t.pixelxy2radec = tan_t_pixelxy2radec

def tan_t_radec2pixelxy(self, r, d):
    return tan_rd2xy_wrapper(self.this, r, d)
tan_t.radec2pixelxy_single = tan_t.radec2pixelxy
tan_t.radec2pixelxy = tan_t_radec2pixelxy

def tan_t_iwc2pixelxy(self, r, d):
    return tan_iwc2xy_wrapper(self.this, r, d)
tan_t.iwc2pixelxy_single = tan_t.iwc2pixelxy
tan_t.iwc2pixelxy = tan_t_iwc2pixelxy

def tan_t_pixelxy2iwc(self, x,y):
    return tan_xy2iwc_wrapper(self.this, x,y)
tan_t.pixelxy2iwc_single = tan_t.pixelxy2iwc
tan_t.pixelxy2iwc = tan_t_pixelxy2iwc

def tan_t_radec2iwc(self, r, d):
    return tan_rd2iwc_wrapper(self.this, r, d)
tan_t.radec2iwc_single = tan_t.radec2iwc
tan_t.radec2iwc = tan_t_radec2iwc

def tan_t_iwc2radec(self, u, v):
    return tan_iwc2rd_wrapper(self.this, u, v)
tan_t.iwc2radec_single = tan_t.iwc2radec
tan_t.iwc2radec = tan_t_iwc2radec

def sip_t_pixelxy2radec(self, x, y):
    return sip_xy2rd_wrapper(self.this, x, y)
sip_t.pixelxy2radec_single = sip_t.pixelxy2radec
sip_t.pixelxy2radec = sip_t_pixelxy2radec

def sip_t_radec2pixelxy(self, r, d):
    return sip_rd2xy_wrapper(self.this, r, d)
sip_t.radec2pixelxy_single = sip_t.radec2pixelxy
sip_t.radec2pixelxy = sip_t_radec2pixelxy

def sip_t_iwc2pixelxy(self, r, d):
    return sip_iwc2xy_wrapper(self.this, r, d)
sip_t.iwc2pixelxy_single = sip_t.iwc2pixelxy
sip_t.iwc2pixelxy = sip_t_iwc2pixelxy

def sip_t_pixelxy2iwc(self, x,y):
    return sip_xy2iwc_wrapper(self.this, x,y)
sip_t.pixelxy2iwc_single = sip_t.pixelxy2iwc
sip_t.pixelxy2iwc = sip_t_pixelxy2iwc

def sip_t_radec2iwc(self, r, d):
    return sip_rd2iwc_wrapper(self.this, r, d)
sip_t.radec2iwc_single = sip_t.radec2iwc
sip_t.radec2iwc = sip_t_radec2iwc

def sip_t_iwc2radec(self, u, v):
    return sip_iwc2rd_wrapper(self.this, u, v)
sip_t.iwc2radec_single = sip_t.iwc2radec
sip_t.iwc2radec = sip_t_iwc2radec


def anwcs_t_pixelxy2radec(self, x, y):
    ok,r,d =  anwcs_xy2rd_wrapper(self.this, x, y)
    return (ok == 0),r,d
anwcs_t.pixelxy2radec_single = anwcs_t.pixelxy2radec
anwcs_t.pixelxy2radec = anwcs_t_pixelxy2radec

def anwcs_t_radec2pixelxy(self, r, d):
    ok,x,y =  anwcs_rd2xy_wrapper(self.this, r, d)
    return (ok == 0),x,y
anwcs_t.radec2pixelxy_single = anwcs_t.radec2pixelxy
anwcs_t.radec2pixelxy = anwcs_t_radec2pixelxy

def tan_t_radec_bounds(self):
    W,H = self.imagew, self.imageh
    r,d = self.pixelxy2radec([1, W/2, W, W, W, W/2, 1, 1], [1, 1, 1, H/2, H, H, H, H/2])
    rx = r.max()
    rn = r.min()
# ugh, RA wrap-around.  We find the largest value < 180 (ie, near zero) and smallest value > 180 (ie, near 360)
# and report them with ralo > rahi so that this case can be identified
    if rx - rn > 180:
        rx = r[r < 180].max()
        rn = r[r > 180].min()
    return (rn, rx, d.min(), d.max())
tan_t.radec_bounds = tan_t_radec_bounds

_real_tan_t_init = tan_t.__init__
def my_tan_t_init(self, *args, **kwargs):
# fitsio header: check for '.records()' function.
    if len(args) == 1 and hasattr(args[0], 'records'):
        try:
            hdr = args[0]
            qhdr = fitsio_to_qfits_header(hdr)
            args = [qhdr]
        except:
            pass

    _real_tan_t_init(self, *args, **kwargs)
    if self.this is None:
        raise RuntimeError('Duck punch!')
tan_t.__init__ = my_tan_t_init

Tan = tan_t

def tan_t_get_subimage(self, x0, y0, w, h):
    wcs2 = tan_t(self)
    cpx,cpy = wcs2.crpix
    wcs2.set_crpix(cpx - x0, cpy - y0)
    wcs2.set_width(float(w))
    wcs2.set_height(float(h))
    return wcs2
tan_t.get_subimage = tan_t_get_subimage

# Deja Vu!
# def sip_t_get_subimage(self, xlo, xhi, ylo, yhi):
#     sipout = sip_t(self)
#     sip_shift(self.this, sipout.this, float(xlo), float(xhi), float(ylo), float(yhi))
#     return sipout
# sip_t.get_subimage = sip_t_get_subimage

# picklable
def sip_t_getstate(self):
    t = (self.wcstan.__getstate__(),
         self.a_order, self.b_order, self.a, self.b,
         self.ap_order, self.bp_order, self.ap, self.bp)
    return t

def sip_t_setstate(self, s):
    self.this = _util.new_sip_t()
    (t, self.a_order, self.b_order, self.a, self.b,
     self.ap_order, self.bp_order, self.ap, self.bp) = s
#self.wcstan.__setstate__(t)
# disturbingly, tan_t_setstate does not work because it resets self.this = ...
    p0,p1,v0,v1,cd0,cd1,cd2,cd3,w,h,sin = t
    self.wcstan.set_crpix(p0,p1)
    self.wcstan.set_crval(v0,v1)
    self.wcstan.set_cd(cd0,cd1,cd2,cd3)
    self.wcstan.set_imagesize(w,h)
    self.wcstan.sin = sin

def sip_t_getnewargs(self):
    return ()

sip_t.__getstate__ = sip_t_getstate
sip_t.__setstate__ = sip_t_setstate
sip_t.__getnewargs__ = sip_t_getnewargs



def fits_use_error_system():
    return _util.fits_use_error_system()

def fits_to_string(hdr, size):
    return _util.fits_to_string(hdr, size)

def fits_write_float_image(img, nx, ny, fn):
    return _util.fits_write_float_image(img, nx, ny, fn)

def fits_write_u8_image(img, nx, ny, fn):
    return _util.fits_write_u8_image(img, nx, ny, fn)

def fits_write_i16_image(img, nx, ny, fn):
    return _util.fits_write_i16_image(img, nx, ny, fn)

def fits_get_header_for_image(qd, W, addtoheader):
    return _util.fits_get_header_for_image(qd, W, addtoheader)

def fits_get_header_for_image2(W, H, bitpix, addtoheader):
    return _util.fits_get_header_for_image2(W, H, bitpix, addtoheader)

def fits_get_header_for_image3(W, H, bitpix, planes, addtoheader):
    return _util.fits_get_header_for_image3(W, H, bitpix, planes, addtoheader)

def fits_write_header(hdr, filename):
    return _util.fits_write_header(hdr, filename)

def fits_write_header_and_image(hdr, qd, W):
    return _util.fits_write_header_and_image(hdr, qd, W)

def fits_get_double_val(table, column, rowdata):
    return _util.fits_get_double_val(table, column, rowdata)

def fits_is_table_header(keyword):
    return _util.fits_is_table_header(keyword)

def fits_is_primary_header(key):
    return _util.fits_is_primary_header(key)

def fits_copy_non_table_headers(dest, src):
    return _util.fits_copy_non_table_headers(dest, src)

def fits_get_dupstring(hdr, key):
    return _util.fits_get_dupstring(hdr, key)

def fits_get_long_string(hdr, key):
    return _util.fits_get_long_string(hdr, key)

def fits_header_addf(*args):
    return _util.fits_header_addf(*args)

def fits_header_addf_longstring(*args):
    return _util.fits_header_addf_longstring(*args)

def fits_header_add_longstring_boilerplate(hdr):
    return _util.fits_header_add_longstring_boilerplate(hdr)

def fits_header_modf(*args):
    return _util.fits_header_modf(*args)

def fits_header_add_int(hdr, key, val, comment):
    return _util.fits_header_add_int(hdr, key, val, comment)

def fits_header_add_double(hdr, key, val, comment):
    return _util.fits_header_add_double(hdr, key, val, comment)

def fits_header_set_double(hdr, key, val, comment):
    return _util.fits_header_set_double(hdr, key, val, comment)

def fits_header_set_int(hdr, key, val, comment):
    return _util.fits_header_set_int(hdr, key, val, comment)

def fits_header_mod_int(hdr, key, val, comment):
    return _util.fits_header_mod_int(hdr, key, val, comment)

def fits_header_mod_double(hdr, key, val, comment):
    return _util.fits_header_mod_double(hdr, key, val, comment)

def fits_update_value(hdr, key, newvalue):
    return _util.fits_update_value(hdr, key, newvalue)

def fits_copy_table(tbl):
    return _util.fits_copy_table(tbl)

def an_fits_copy_header(src, dest, key):
    return _util.an_fits_copy_header(src, dest, key)

def fits_copy_all_headers(src, dest, targetkey):
    return _util.fits_copy_all_headers(src, dest, targetkey)

def fits_append_all_headers(src, dest, targetkey):
    return _util.fits_append_all_headers(src, dest, targetkey)

def fits_add_args(src, args, argc):
    return _util.fits_add_args(src, args, argc)

def fits_add_long_comment(*args):
    return _util.fits_add_long_comment(*args)

def fits_append_long_comment(*args):
    return _util.fits_append_long_comment(*args)

def fits_add_long_history(*args):
    return _util.fits_add_long_history(*args)

def fits_blocks_needed(size):
    return _util.fits_blocks_needed(size)

def fits_bytes_needed(size):
    return _util.fits_bytes_needed(size)

def fits_pad_file_with(fid, pad):
    return _util.fits_pad_file_with(fid, pad)

def fits_pad_file(fid):
    return _util.fits_pad_file(fid)

def fits_pad_file_name(filename):
    return _util.fits_pad_file_name(filename)

def fits_fill_endian_string(str):
    return _util.fits_fill_endian_string(str)

def fits_get_endian_string():
    return _util.fits_get_endian_string()

def fits_check_endian(header):
    return _util.fits_check_endian(header)

def fits_check_uint_size(header):
    return _util.fits_check_uint_size(header)

def fits_check_double_size(header):
    return _util.fits_check_double_size(header)

def fits_add_endian(header):
    return _util.fits_add_endian(header)

def fits_add_reverse_endian(header):
    return _util.fits_add_reverse_endian(header)

def fits_mod_reverse_endian(header):
    return _util.fits_mod_reverse_endian(header)

def fits_add_uint_size(header):
    return _util.fits_add_uint_size(header)

def fits_add_double_size(header):
    return _util.fits_add_double_size(header)

def fits_find_column(table, colname):
    return _util.fits_find_column(table, colname)

def fits_find_table_column(fn, colname, start, size, extension):
    return _util.fits_find_table_column(fn, colname, start, size, extension)

def fits_get_table_column(fn, colname, pcol):
    return _util.fits_get_table_column(fn, colname, pcol)

def fits_add_column(table, column, type, ncopies, units, label):
    return _util.fits_add_column(table, column, type, ncopies, units, label)

def fits_offset_of_column(table, colnum):
    return _util.fits_offset_of_column(table, colnum)

def fits_write_data_A(fid, value):
    return _util.fits_write_data_A(fid, value)

def fits_write_data_B(fid, value):
    return _util.fits_write_data_B(fid, value)

def fits_write_data_D(fid, value, flip):
    return _util.fits_write_data_D(fid, value, flip)

def fits_write_data_E(fid, value, flip):
    return _util.fits_write_data_E(fid, value, flip)

def fits_write_data_I(fid, value, flip):
    return _util.fits_write_data_I(fid, value, flip)

def fits_write_data_J(fid, value, flip):
    return _util.fits_write_data_J(fid, value, flip)

def fits_write_data_K(fid, value, flip):
    return _util.fits_write_data_K(fid, value, flip)

def fits_write_data_L(fid, value):
    return _util.fits_write_data_L(fid, value)

def fits_write_data_X(fid, value):
    return _util.fits_write_data_X(fid, value)

def fits_write_data(fid, pvalue, type, flip):
    return _util.fits_write_data(fid, pvalue, type, flip)

def fits_write_data_array(fid, vvalue, type, N, flip):
    return _util.fits_write_data_array(fid, vvalue, type, N, flip)

def collapsing_find_minlabel(label, equivs):
    return _util.collapsing_find_minlabel(label, equivs)

def dfind2(image, nx, ny, objectimg, p_nobjects):
    return _util.dfind2(image, nx, ny, objectimg, p_nobjects)

def dfind2_u8(image, nx, ny, objectimg, p_nobjects):
    return _util.dfind2_u8(image, nx, ny, objectimg, p_nobjects)

def dselip(k, n, arr):
    return _util.dselip(k, n, arr)

def dselip_cleanup():
    return _util.dselip_cleanup()

def dsmooth(image, nx, ny, sigma, smooth):
    return _util.dsmooth(image, nx, ny, sigma, smooth)

def dsmooth2(image, nx, ny, sigma, smooth):
    return _util.dsmooth2(image, nx, ny, sigma, smooth)

def dsmooth2_u8(image, nx, ny, sigma, smooth):
    return _util.dsmooth2_u8(image, nx, ny, sigma, smooth)

def dsmooth2_i16(image, nx, ny, sigma, smooth):
    return _util.dsmooth2_i16(image, nx, ny, sigma, smooth)

def dobjects(image, nx, ny, limit, dpsf, objects):
    return _util.dobjects(image, nx, ny, limit, dpsf, objects)

def dmask(image, nx, ny, limit, dpsf, mask):
    return _util.dmask(image, nx, ny, limit, dpsf, mask)

def dpeaks(image, nx, ny, npeaks, xcen, ycen, sigma, dlim, saddle, maxnpeaks, smooth, checkpeaks, minpeak):
    return _util.dpeaks(image, nx, ny, npeaks, xcen, ycen, sigma, dlim, saddle, maxnpeaks, smooth, checkpeaks, minpeak)

def dcen3x3(image):
    return _util.dcen3x3(image)

def dsigma(image, nx, ny, sp, gridsize, sigma):
    return _util.dsigma(image, nx, ny, sp, gridsize, sigma)

def dsigma_u8(image, nx, ny, sp, gridsize, sigma):
    return _util.dsigma_u8(image, nx, ny, sp, gridsize, sigma)

def dmedsmooth(image, masked, nx, ny, halfbox, smooth):
    return _util.dmedsmooth(image, masked, nx, ny, halfbox, smooth)

def dallpeaks(image, nx, ny, objects, npeaks, dpsf, sigma, dlim, saddle, maxper, maxnpeaks, minpeak, maxsize):
    return _util.dallpeaks(image, nx, ny, objects, npeaks, dpsf, sigma, dlim, saddle, maxper, maxnpeaks, minpeak, maxsize)

def dallpeaks_u8(image, nx, ny, objects, npeaks, dpsf, sigma, dlim, saddle, maxper, maxnpeaks, minpeak, maxsize):
    return _util.dallpeaks_u8(image, nx, ny, objects, npeaks, dpsf, sigma, dlim, saddle, maxper, maxnpeaks, minpeak, maxsize)

def dallpeaks_i16(image, nx, ny, objects, npeaks, dpsf, sigma, dlim, saddle, maxper, maxnpeaks, minpeak, maxsize):
    return _util.dallpeaks_i16(image, nx, ny, objects, npeaks, dpsf, sigma, dlim, saddle, maxper, maxnpeaks, minpeak, maxsize)

def dcen3x3b(i0, i1, i2, i3, i4, i5, i6, i7, i8):
    return _util.dcen3x3b(i0, i1, i2, i3, i4, i5, i6, i7, i8)


